#include "../inc/ParkingPlannerThread.h"
#include <QPointF>
#include <QDebug>
#include "../inc/CatmullRomSpline.h"
#include <visualization_msgs/Marker.h>  	//Marker messages to visualize objects in Rviz
#include "../inc/nabo/nabo.h"

bool ParkingPlannerThread::ServiceProcess(motion_planner::srvParkingCmd::Request &req,motion_planner::srvParkingCmd::Response &res)
{
    //m_tar_x = req.x;
   //m_tar_y = req.y;
    //m_tar_theta = 0.;

    //m_mode = req.mode;

    //res.result = 1; // 1 is valid response
    return true;
}//added by shinsh - 151006

// Vehicle Current Position from Localization Module
void ParkingPlannerThread::SubTopicProcess1(const std_msgs::Float32MultiArray::ConstPtr& msg)
{
    if(!m_bSubTopicUpdated)
    {
        m_bSubTopicUpdated = true;

        m_pos[0] = msg->data.at(0);
        m_pos[1] = msg->data.at(1);
        m_pos[2] = msg->data.at(2);
        m_vel = msg->data.at(3);
     //   std::cout << "heading " << m_pos[2]<<std::endl;
    }
    
}

void ParkingPlannerThread::publish_parking_path(vector<Vector2d> path)
{
    nav_msgs::Path msg;
    std::vector<geometry_msgs::PoseStamped> waypoints;
    msg.header.frame_id = "/camera_init";
    msg.header.stamp = ros::Time::now();


    //////////////////////////////////////////
    // POSE STAMPED
    for(int i=0; i<path.size(); i++)
    {
        geometry_msgs::PoseStamped waypt;
        waypt.header.frame_id = "/camera_init";
        waypt.header.stamp = ros::Time::now();


        waypt.pose.position.x = path[i][0];
        waypt.pose.position.y = path[i][1];
        waypt.pose.position.z = 0;
        waypoints.push_back(waypt);

    }

    msg.poses.resize(waypoints.size());

    // Extract the plan in world coordinates, we assume the path is all in the same frame
    for(unsigned int i=0; i < waypoints.size(); i++)
    {
        msg.poses[i] = waypoints[i];
    }
    msgpub.publish(msg);

}


ParkingPlannerThread::ParkingPlannerThread(int argc, char** argv)
    :m_bThreadStop(false),init_argc(argc), init_argv(argv)
{
    ros::init(init_argc, init_argv, "ParkingPlannerThread");
    ros::NodeHandle n;

    m_bSubTopicUpdated = false;
   
    possub = n.subscribe("my_pose2", 10, &ParkingPlannerThread::SubTopicProcess1, this);
    msgpub = n.advertise<nav_msgs::Path>("LocalPathData", 10);
    service_server = n.advertiseService("parking_cmd_srv", &HeightMap::ServiceProcess, this);
    service_client = n.serviceClient<motion_planner::srvHeightMap>("height_map_srv");
}

ParkingPlannerThread::~ParkingPlannerThread()
{

}
void ParkingPlannerThread::stop()
{
    qDebug()<<"Thread::stop called from main thread:"<<currentThreadId();
    QMutexLocker locker(&m_mutex);
    m_bThreadStop = true;
}

void ParkingPlannerThread::PubMsg()
{
   publish_parking_path(m_LocalParkingPath);
}

void ParkingPlannerThread::run()
{
    int cntLoop =0;
    int index =0;
    ros::Rate loop_rate(10);
    while(1)
    {
        {
            QMutexLocker locker(&m_mutex);
            if(m_bThreadStop) break;

            if(m_bSubTopicUpdated )
            {
		motion_planner::srvHeightMap srv;
		srv.request.x = 12.0;
		srv.request.y = -5.0;
		srv.request.theta = 0.0;
		srv.request.mode = 2.0;

		if( service_client.call(srv) )
		{
			std::cout << "receive from heightmap srv !\n";	
		}
                ////////////////////////////////////////////////////////////////
                m_bSubTopicUpdated = false;
            }

        }
        ros::spinOnce();
        loop_rate.sleep();
        
    }
}
